{"version":3,"names":[],"mappings":"","sources":["tile-sorter.js"],"sourcesContent":["class TileSorter {\r\n    constructor({\r\n        controlSelector,\r\n        tileSelector,\r\n        initByClick = true,\r\n        duration = 500,\r\n        timingFunction,\r\n    }) {\r\n        this._controlSelector = controlSelector;\r\n        this._initByClick = initByClick;\r\n        this._duration = duration;\r\n        this._timingFn = timingFunction || this._linearTimingFn;\r\n\r\n        this._tags = [];\r\n        this._resetFilterControl = null;\r\n        this._controls = [];\r\n\r\n        [ ...document.querySelectorAll(controlSelector) ].forEach(DOMNode => {\r\n            if (DOMNode.value === \"*\") {\r\n                this._resetFilterControl = DOMNode;\r\n            }\r\n            else {\r\n                this._tags.push(DOMNode.value);\r\n            }\r\n\r\n            this._controls.push({\r\n                DOMNode,\r\n                tag: DOMNode.value,\r\n            });\r\n        });\r\n\r\n        this._tiles = [ ...document.querySelectorAll(tileSelector) ].map(DOMNode => ({\r\n            DOMNode,\r\n            tags: DOMNode.dataset.tileTags.split(\",\"),\r\n        }));\r\n        this._wrapper = {\r\n            DOMNode: this._tiles[0].DOMNode.parentElement,\r\n        };\r\n\r\n        this._filterTags = [];\r\n        this._validTags = [...this._tags];\r\n\r\n        this._visibleTiles = [...this._tiles];\r\n        this._hiddenTiles = [];\r\n\r\n        this._onBeforeAnimationStart = this._onBeforeAnimationStart.bind(this);\r\n        this._animationHandler = this._animationHandler.bind(this);\r\n        this._onAnimationEnd = this._onAnimationEnd.bind(this);\r\n\r\n        this._inited = false;\r\n        window.addEventListener(\"load\", this._init.bind(this), { once: true });\r\n    }\r\n\r\n    _init() {\r\n        this._snapInitialState();\r\n\r\n        document.addEventListener(\"click\", this._controlsClickHandler.bind(this));\r\n\r\n        if (!this._initByClick) {\r\n            this._setInitialState();\r\n        }\r\n    }\r\n\r\n    _snapInitialState() {\r\n        const wrapper = this._wrapper;\r\n        const wrapperDOMNode = wrapper.DOMNode;\r\n        const wrapperStyle = getComputedStyle(wrapperDOMNode);\r\n        wrapper.snappedSizes = {\r\n            height:         wrapperDOMNode.offsetHeight,\r\n            paddingTop:     parseFloat(wrapperStyle.paddingTop),\r\n            paddingRight:   parseFloat(wrapperStyle.paddingRight),\r\n            paddingBottom:  parseFloat(wrapperStyle.paddingBottom),\r\n            paddingLeft:    parseFloat(wrapperStyle.paddingLeft),\r\n            borderRight:    parseFloat(wrapperStyle.borderRightWidth),\r\n            borderLeft:     parseFloat(wrapperStyle.borderLeftWidth),\r\n        };\r\n\r\n        // принудительно устанавливаем position: relative для враппера\r\n        // чтобы корректно посчитать исходные координаты для тайлов\r\n        wrapperDOMNode.style.position = \"relative\";\r\n\r\n        let tilesInRow = 0;\r\n        let prevTileTop = null;\r\n\r\n        this._tiles.forEach(tile => {\r\n            const { DOMNode } = tile;\r\n\r\n            if (prevTileTop === null || DOMNode.offsetTop === prevTileTop) {\r\n                tilesInRow++;\r\n                prevTileTop = DOMNode.offsetTop;\r\n            }\r\n\r\n            tile.snappedSizes = {\r\n                height: DOMNode.offsetHeight,\r\n                top:    DOMNode.offsetTop,\r\n            };\r\n        });\r\n\r\n        // TODO брать отступы у каждой тайлы?\r\n        const tileStyle = getComputedStyle(this._tiles[0].DOMNode);\r\n        this._tileDefaults = {\r\n            display:    tileStyle.display,\r\n            top:        this._tiles[0].snappedSizes.top,\r\n            bottom:     parseFloat(tileStyle.marginBottom),\r\n        };\r\n\r\n        this._tilesInRow = tilesInRow;\r\n        this._currentTileWidth = (\r\n            wrapperDOMNode.offsetWidth\r\n            - wrapper.snappedSizes.paddingRight\r\n            - wrapper.snappedSizes.paddingLeft\r\n            - wrapper.snappedSizes.borderRight\r\n            - wrapper.snappedSizes.borderLeft\r\n        ) / tilesInRow;\r\n    }\r\n\r\n    _controlsClickHandler(event) {\r\n        const target = event.target.closest(this._controlSelector);\r\n\r\n        if (!target) return;\r\n\r\n        if (!this._inited) {\r\n            this._setInitialState();\r\n        }\r\n\r\n        const filterTag = target.value;\r\n        const isNewTag = target.checked;\r\n\r\n        if (filterTag === \"*\") {\r\n            this._filterTags.length = 0;\r\n        }\r\n        else if (isNewTag) {\r\n            this._filterTags.push(filterTag);\r\n        }\r\n        else {\r\n            this._filterTags = this._filterTags.filter(item => item !== filterTag);\r\n        }\r\n\r\n        this._filter();\r\n        this._updateControlsState(target);\r\n        // TODO запилить проверку факта изменения фильтра?\r\n        this._startAnimation();\r\n    }\r\n\r\n    _setInitialState() {\r\n        this._animate(() => {\r\n            this._wrapper.DOMNode.style.height = `${this._wrapper.snappedSizes.height}px`;\r\n\r\n            this._tiles.forEach((tile, index) => {\r\n                const { DOMNode } = tile;\r\n\r\n                DOMNode.style = `\r\n                    position: absolute;\r\n                    top: ${tile.snappedSizes.top}px;\r\n                    left: ${this._currentTileWidth * (index % this._tilesInRow)}px;\r\n                    width: ${this._currentTileWidth}px;\r\n                `;\r\n                // запоминаем собственную высоту тайла и ставим обратно исходную\r\n                // это нужно для выравнивания тайлов в строке по высоте\r\n                tile.snappedSizes.selfHeight = DOMNode.offsetHeight;\r\n                DOMNode.style.height = `${tile.snappedSizes.height}px`;\r\n            });\r\n        });\r\n\r\n        this._inited = true;\r\n    }\r\n\r\n    _filter() {\r\n        const isFilterReseted = this._filterTags.length === 0;\r\n\r\n        this._hiddenTiles = [];\r\n\r\n        if (isFilterReseted) {\r\n            this._validTags = [...this._tags];\r\n            this._visibleTiles = [...this._tiles];\r\n        }\r\n        else {\r\n            const validTags = new Set();\r\n            this._visibleTiles = [];\r\n\r\n            this._tiles.forEach(tile => {\r\n                if ( this._filterTags.every(tag => tile.tags.includes(tag)) ) {\r\n                    tile.tags.forEach(tag => validTags.add(tag));\r\n                    this._visibleTiles.push(tile);\r\n                }\r\n                else {\r\n                    this._hiddenTiles.push(tile);\r\n                }\r\n            });\r\n\r\n            this._validTags = [ ...validTags.values() ];\r\n        }\r\n    }\r\n\r\n    _updateControlsState(clickedTarget) {\r\n        const isFilterReseted = clickedTarget === this._resetFilterControl || !this._filterTags.length;\r\n\r\n        this._controls.forEach(control => {\r\n            const { DOMNode } = control;\r\n\r\n            if (isFilterReseted) {\r\n                DOMNode.checked = false;\r\n                DOMNode.disabled = false;\r\n            }\r\n            else if (DOMNode !== this._resetFilterControl) {\r\n                DOMNode.disabled = !this._validTags.includes(control.tag);\r\n            }\r\n        });\r\n\r\n        this._resetFilterControl.checked = isFilterReseted;\r\n    }\r\n\r\n    _startAnimation() {\r\n        this._setAnimationData();\r\n        this._animate(this._onBeforeAnimationStart);\r\n        this._animationStartTime = null;\r\n        this._animate(this._animationHandler);\r\n    }\r\n\r\n    _setAnimationData() {\r\n        this._tilesToAnimate = [];\r\n\r\n        let currentRow = 0;\r\n        let rowHeight = this._visibleTiles[0].snappedSizes.selfHeight;\r\n        let rowToAdjust = null;\r\n        let topOffset = this._wrapper.snappedSizes.paddingTop;\r\n\r\n        this._tiles.forEach(tile => {\r\n            const style = getComputedStyle(tile.DOMNode);\r\n            const visibleIndex = this._visibleTiles.indexOf(tile);\r\n            tile.animationData = {\r\n                hide: false,\r\n                show: false,\r\n            };\r\n\r\n            if (visibleIndex !== -1) {\r\n                const { selfHeight } = tile.snappedSizes;\r\n                const currentRowTmp = Math.floor(visibleIndex / this._tilesInRow);\r\n                const isNewRow = currentRow !== currentRowTmp;\r\n                const isShiftOccurred = !isNewRow && selfHeight > rowHeight;\r\n                currentRow = currentRowTmp;\r\n\r\n                if (isNewRow) {\r\n                    if (rowToAdjust !== null) {\r\n                        this._adjustRowHeight(rowToAdjust, rowHeight);\r\n                    }\r\n                    rowToAdjust = null;\r\n                    topOffset += this._visibleTiles[visibleIndex - 1].height + this._tileDefaults.bottom;\r\n                }\r\n\r\n                if (isShiftOccurred) {\r\n                    rowToAdjust = currentRow;\r\n                }\r\n\r\n                rowHeight = isNewRow || isShiftOccurred ? selfHeight : rowHeight;\r\n\r\n                const to = {\r\n                    height: selfHeight < rowHeight ? rowHeight : selfHeight,\r\n                    top:    topOffset,\r\n                    left:   (\r\n                        this._wrapper.snappedSizes.paddingLeft\r\n                        + this._currentTileWidth * (visibleIndex % this._tilesInRow)\r\n                    ),\r\n                };\r\n                tile.animationData.to = to;\r\n\r\n                if (style.display !== \"none\") {\r\n                    const from = {\r\n                        height: parseFloat(style.height),\r\n                        top:    parseFloat(style.top),\r\n                        left:   parseFloat(style.left),\r\n                    };\r\n                    tile.animationData.from = from;\r\n\r\n                    tile.animationData.diff = {\r\n                        height: to.height - from.height,\r\n                        top:    to.top - from.top,\r\n                        left:   to.left - from.left,\r\n                    };\r\n                }\r\n                else {\r\n                    tile.animationData.show = true;\r\n                }\r\n            }\r\n\r\n            if ( this._hiddenTiles.includes(tile) ) {\r\n                if (style.display === \"none\") return;\r\n\r\n                tile.animationData.hide = true;\r\n            }\r\n\r\n            this._tilesToAnimate.push(tile);\r\n        });\r\n\r\n        const wrapperDOMNode = this._wrapper.DOMNode;\r\n        this._wrapper.animationData = {\r\n            from: {\r\n                height: wrapperDOMNode.height\r\n            },\r\n        };\r\n\r\n        const a = (\r\n            topOffset\r\n            + this._visibleTiles[this._visibleTiles.length - 1].animationData.to.height\r\n        );\r\n\r\n        console.log(this._tiles.reduce((acc, tile) => acc += `${tile.animationData?.diff?.height} `, \"\"));\r\n    }\r\n\r\n    _adjustRowHeight(rowToAdjust, rowHeight) {\r\n        let tilesNotChanging = [];\r\n\r\n        for (let i = rowToAdjust * this._tilesInRow, end = i + this._tilesInRow; i < end; i++) {\r\n            const tile = this._visibleTiles[i];\r\n            const { animationData: { to, from, diff } } = tile;\r\n            to.height = rowHeight;\r\n            diff.height = to.height - from.height;\r\n\r\n            if (diff.height === 0 && diff.top === 0 && diff.left === 0) {\r\n                tilesNotChanging.push(tile);\r\n            }\r\n        }\r\n\r\n        // TODO splice?\r\n        this._tilesToAnimate = this._tilesToAnimate.filter(tile => !tilesNotChanging.includes(tile));\r\n    }\r\n\r\n    _onBeforeAnimationStart() {\r\n        this._tilesToAnimate.forEach(tile => {\r\n            const { DOMNode, animationData: { to, show } } = tile;\r\n\r\n            if (show) {\r\n                DOMNode.style.display = this._tileDefaults.display;\r\n                DOMNode.style.top = `${to.top}px`;\r\n                DOMNode.style.left = `${to.left}px`;\r\n                DOMNode.style.height = `${to.left}px`;\r\n                DOMNode.style.transform = \"scale(0)\";\r\n            }\r\n        });\r\n    }\r\n\r\n    _linearTimingFn(timeFraction) {\r\n        return timeFraction;\r\n    }\r\n\r\n    _animate(fn) {\r\n        requestAnimationFrame(fn);\r\n    }\r\n\r\n    _animationHandler(time) {\r\n        this._animationStartTime ||= time;\r\n        const start = this._animationStartTime;\r\n        let progress = (time - start) / this._duration;\r\n        progress = progress > 1 ? 1 : progress;\r\n\r\n        this._tilesToAnimate.forEach(tile => {\r\n            const { DOMNode } = tile;\r\n            const { from, diff, show, hide } = tile.animationData;\r\n\r\n            if (show) {\r\n                DOMNode.style.transform = `scale(${progress})`;\r\n            }\r\n            else if (hide) {\r\n                DOMNode.style.transform = `scale(${1 - progress})`;\r\n            }\r\n            else {\r\n                DOMNode.style.top = `${from.top + diff.top * progress}px`;\r\n                DOMNode.style.left = `${from.left + diff.left * progress}px`;\r\n                DOMNode.style.height = `${from.height + diff.height * progress}px`;\r\n            }\r\n        });\r\n\r\n        if (progress < 1) {\r\n            this._animate(this._animationHandler);\r\n        }\r\n        else {\r\n            this._animate(this._onAnimationEnd);\r\n        }\r\n    }\r\n\r\n    _onAnimationEnd() {\r\n        this._hiddenTiles.forEach(({ DOMNode }) => {\r\n            DOMNode.style.display = \"none\";\r\n        });\r\n    }\r\n}\r\n"],"file":"tile-sorter.min.js"}